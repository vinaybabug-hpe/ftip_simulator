# for objects with only two features and two clusters

Objects / Clusters = 
18	23
5	22
8	9
10	3
14	16
1	6
2	14
2	23


membership =
-1
-1
-1
-1
-1
-1
-1
-1


newClusterSize =
0
0

newClusters = 
0 2
4 6


/*----< seq_kmeans() >-------------------------------------------------------*/
/* return an array of cluster centers of size [numClusters][numCoords]       */
int seq_kmeans(char dist,
			   float **objects,      /* in: [numObjs][numCoords] */				  
               //int     numCoords = 2,    /* no. features */
               int     numObjs = 16,      /* no. objects */
               int     numClusters = 2,  /* no. clusters */
               float   threshold,    /* % objects change membership */
               int    *membership,   /* out: [numObjs] */
               float **clusters     /* out: [numClusters][numCoords] */
               )

{
    int      i, j, index, loop=0;
    int     *newClusterSize; /* [numClusters]: no. objects assigned in each
                                new cluster */
							
    
    float  **newClusters;    /* [numClusters][numCoords] */  

    /* initialize membership[] */
    for (i=0; i<numObjs; i++) membership[i] = -1;


    /* need to initialize newClusterSize and newClusters[0] to all 0 */
    newClusterSize = (int*) calloc(numClusters, sizeof(int));
    assert(newClusterSize != NULL);

    newClusters    = (float**) malloc(numClusters * sizeof(float*));
    assert(newClusters != NULL);
    newClusters[0] = (float*)  calloc(numClusters * 2, sizeof(float));
    assert(newClusters[0] != NULL);
    for (i=1; i<numClusters; i++)
        newClusters[i] = newClusters[i-1] + 2;

    for (i=0; i<numClusters; i++) {
    	for (j=0; j<2; j++) {
    		clusters[i][j] = objects[i][j];    		
    	}
    }

    do {
        delta = 0.0;
        for (i=0; i<numObjs; i++) {
            /* find the array index of nestest cluster center */
            //index = find_nearest_cluster(numClusters, numCoords, objects, i, clusters, dist);
			

				
				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				float term1 = data1[i][0] - clusters[0][0];
				result += term1*term1;
				float term2 = data1[i][1] - clusters[0][1];
				result += term2*term2;
				
				min_dist = result;


				result = 0;
				// CLUSTER 0
					float term1 = data1[i][0] - clusters[0][0];
					result += term1*term1;
					float term2 = data1[i][1] - clusters[0][1];
					result += term2*term2;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					float term1 = data1[i][0] - clusters[1][0];
					result += term1*term1;
					float term2 = data1[i][1] - clusters[1][1];
					result += term2*term2;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
        }
		######################## 1st object
		float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				0 = 18 - 18;
				0 += 0*0;
				0 = 23 - 23;
				0 += 0*0;
				
				min_dist = 0;


				result = 0;
				// CLUSTER 0
					0 = 18 - 18;
					0 += 0*0;
					0 = 23 - 23;
					0 += 0*0;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					13 = 18 - 5;
					169 += 13*13;
					1 = 23 - 22;
					result += 1*1;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				
			// at the end index = 0 

            /* if membership changes, increase delta by 1 */
            if (membership[0] != index) delta += 1.0;

            /* assign the membership to object i */
			
            membership[0] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[0][0];
			newClusters[index][1] += objects[0][1];
		########################
		
membership =
0
-1
-1
-1
-1
-1
-1
-1


newClusterSize =
1
0

newClusters = 
0+18 23+2
4 6

		######################## 2nd object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				-13 = 5 - 18;
				169 += (-13)*(-13);
				-1 = 22 - 23;
				1 += (-1)*(-1);
				
				min_dist = 1;


				result = 1;
				// CLUSTER 0
					-13 = 5 - 18;
					169 += (-13)*(-13);
					-1 = 22 - 23;
					169 += (-1)*(-1);
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					0 = 5 - 5;
					result += 0*0;
					0 = 22 - 22;
					0 += 0*0;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				# min_dist = 0
				# index = 1
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
-1
-1
-1
-1
-1
-1


newClusterSize =
1
1

newClusters = 
0+18 23+2
4+5 6+22


######################## 3rd object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				-10 = 8 - 18;
				100 += (10)*(-10);
				# result = 100
				-14 = 9 - 23;
				296 += (-14)*(-14);
				# result = 296
				
				min_dist = result;
				# min_dist = 296


				result = 0;
				// CLUSTER 0
					-10 = 8 - 18;
					100 += (10)*(-10);
					# result = 100
					-14 = 9 - 23;
					296 += (-14)*(-14);
					# result = 296
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					3 = 8 - 5;
					9 += 3*3;
					-13 = 9 - 22;
					169 + 9 += (-13)*(-13);
					# result = 178
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				# min_dist = 178
				# index = 1

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;
			

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
-1
-1
-1
-1
-1


newClusterSize =
1
2

newClusters = 
0+18 23+2
4+5+8 6+22+9


######################## 4th object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				-8 = 10 - 18;
				64 += (-8)*(-8);
				-20 = 3 - 23;
				64 + 400 = (-20)*(-20);
				
				min_dist = result;
				# min_dist = 464

				result = 0;
				// CLUSTER 0
					-8 = 10 - 18;
					64 += (-8)*(-8);
					-20 = 3 - 23;
					64 + 400 = (-20)*(-20);
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					-5 = 10 - 5;
					25 += (-5)*(-5);
					-19 = 3 - 22;
					25 + 361 = (-19)*(-19);
					
					# result = 386
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				# min_dist = 386
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;
			# index = 1
			
            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
1
-1
-1
-1
-1


newClusterSize =
1
3

newClusters = 
0+18 23+2
4+5+8+10 6+22+9+3

######################## 5th object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				-4 = 14 - 18;
				16 += (-4)*(-4);
				-7 = 16 - 23;
				16 + 49 += (-7)*(-7);
				
				min_dist = result;
				# min_dist = 65

				result = 0;
				// CLUSTER 0
					-4 = 14 - 18;
					16 += (-4)*(-4);
					-7 = 16 - 23;
					16 + 49 += (-7)*(-7);
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					9 = 14 - 5;
					81 += 9*9;
					-6 = 16 - 22;
					81 + 36 += (-6)*(-6);
					# result = 117
					
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				
				# min_dist = 65
				# index = 0
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
1
0
-1
-1
-1


newClusterSize =
2
3

newClusters = 
0+18+14 23+2+16
4+5+8+10 6+22+9+3

######################## 6th object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
					-17 = 1 - 18;
					289 += (-17)*(-17);
					-17 = 6 - 23;
					289 + 289 += (-17)*(-17);
				
				min_dist = result;
				# min_dist = 578

				result = 0;
				// CLUSTER 0
					-17 = 1 - 18;
					289 += (-17)*(-17);
					-17 = 6 - 23;
					289 + 289 += (-17)*(-17);					
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					-4 = 1 - 5;
					16 += (-4)*(-4);
					-16 = 6 - 22;
					256 + 16 += (-16)*(-16);
					# result = 272
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				
					# index = 1

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
1
0
1
-1
-1


newClusterSize =
2
4

newClusters = 
0+18+14 23+2+16
4+5+8+10+1 6+22+9+3+16

######################## 7th object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
					-16 = 2 - 18;
					256 += (-16)*(-16);
					-9 = 14 - 23;
					81 += (-9)*(-9);
				
				min_dist = result;
				# min_dist 81

				result = 0;
				// CLUSTER 0
					-16 = 2 - 18;
					256 += (-16)*(-16);
					-9 = 14 - 23;
					81 += (-9)*(-9);
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					-3 = 2 - 5;
					9 += (-3)*(-3);
					-6 = 14 - 22;
					9 + 36 += (-6)*(-6);
					# result = 45
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				# min_dist = 45
				# index = 1
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
1
0
1
1
-1


newClusterSize =
2
5

newClusters = 
0+18+14 23+2+16
4+5+8+10+1+2 6+22+9+3+16+14

######################## 8th object

				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				-16 = 2 - 18;
				256 += (-16)*(-16);
				0 = 23 - 23;
				256 += 0*0;
				
				min_dist = result;
				# min_dist = 256

				result = 0;
				// CLUSTER 0
					-16 = 2 - 18;
					256 += (-16)*(-16);
					0 = 23 - 23;
					256 += 0*0;
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 0;
					}
					
				
				result = 0;
				// CLUSTER 1
					-3 = 2 - 5;
					9 += (-3)*(-3);
					1 = 23 - 22;
					9 + 1 += 1*1;
					# result = 10
					
					/* no need square root */
					if (result < min_dist) { /* find the min and its array index */
						min_dist = result;
						index    = 1;
					}					
				# min_dist = 10
				# index = 1
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            newClusters[index][0] += objects[i][0];
			newClusters[index][1] += objects[i][1];
		########################
		
membership =
0
1
1
1
0
1
1
1


newClusterSize =
2
6

newClusters = 
0+18+14 23+2+16
4+5+8+10+1+2+2 6+22+9+3+16+14+23

		########################
			
        /* average the sum and replace old cluster center with newClusters */
      
         // CLUSTER 0    
			// FEATURE 0
                if (newClusterSize[0] > 0)
                    clusters[0][0] = newClusters[0][0] / newClusterSize[0];                	
                	newClusters[0][0] = 0.0;   /* set back to 0 */
					clusters[0][0] = newClusters[0][0] / newClusterSize[0];                	
                	newClusters[0][0] = 0.0;   /* set back to 0 */
					
			// FEATURE 1
                if (newClusterSize[0] > 0)
                    clusters[0][1] = newClusters[0][1] / newClusterSize[0];                	
                	newClusters[0][1] = 0.0;   /* set back to 0 */
					clusters[0][1] = newClusters[0][0] / newClusterSize[0];                	
                	newClusters[0][1] = 0.0;   /* set back to 0 */
			newClusterSize[0] = 0;   /* set back to 0 */

         // CLUSTER 1    
			// FEATURE 0
                if (newClusterSize[1] > 0)
                    clusters[1][0] = newClusters[1][0] / newClusterSize[1];                	
                	newClusters[1][0] = 0.0;   /* set back to 0 */
					clusters[1][0] = newClusters[1][0] / newClusterSize[1];                	
                	newClusters[1][0] = 0.0;   /* set back to 0 */
					
			// FEATURE 1
                if (newClusterSize[1] > 0)
                    clusters[1][1] = newClusters[1][1] / newClusterSize[1];                	
                	newClusters[1][1] = 0.0;   /* set back to 0 */
					clusters[1][1] = newClusters[1][0] / newClusterSize[1];                	
                	newClusters[1][1] = 0.0;   /* set back to 0 */
					
            newClusterSize[1] = 0;   /* set back to 0 */
       
            
        delta /= numObjs;
    } while (delta > threshold && loop++ < 500);

    free(newClusters[0]);
    free(newClusters);
    free(newClusterSize);

    return 1;
}