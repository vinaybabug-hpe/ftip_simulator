#

/*----< seq_kmeans() >-------------------------------------------------------*/
/* return an array of cluster centers of size [numClusters][numCoords]       */
int seq_kmeans(char dist,
			   float **objects,      /* in: [numObjs][numCoords] */				  
               int     numCoords,    /* no. features */
               int     numObjs,      /* no. objects */
               int     numClusters,  /* no. clusters */
               float   threshold,    /* % objects change membership */
               int    *membership,   /* out: [numObjs] */
               float **clusters     /* out: [numClusters][numCoords] */
               )

{
    int      i, j, index, loop=0;
    int     *newClusterSize; /* [numClusters]: no. objects assigned in each
                                new cluster */
    
    float  **newClusters;    /* [numClusters][numCoords] */    

    /* initialize membership[] */
    for (i=0; i<numObjs; i++) membership[i] = -1;

    /* need to initialize newClusterSize and newClusters[0] to all 0 */
    newClusterSize = (int*) calloc(numClusters, sizeof(int));
    assert(newClusterSize != NULL);

    newClusters    = (float**) malloc(numClusters * sizeof(float*));
    assert(newClusters != NULL);
    newClusters[0] = (float*)  calloc(numClusters * numCoords, sizeof(float));
    assert(newClusters[0] != NULL);
    for (i=1; i<numClusters; i++)
        newClusters[i] = newClusters[i-1] + numCoords;

    for (i=0; i<numClusters; i++) {
    	for (j=0; j<numCoords; j++) {
    		clusters[i][j] = objects[i][j];    		
    	}
    }

    do {
        delta = 0.0;
        for (i=0; i<numObjs; i++) {
            /* find the array index of nestest cluster center */
            //index = find_nearest_cluster(numClusters, numCoords, objects, i, clusters, dist);
			

				int   i;
				float dist, min_dist;


				/* find the cluster id that has min distance to object */
				index    = 0;
				//min_dist = distancematrix(numCoords, objects, clusters, oIndex, 0, cdist, 0);
				
				for (i = 0; i < numCoords; i++)
				{ 
				  float term = data1[oIndex][i] - data2[0][i];
				  result += term*term;
				}

				for (i=1; i<numClusters; i++) {
					//dist = distancematrix(numCoords, objects, clusters, oIndex, i, cdist, 0);
					
					for (j = 0; j < numCoords; j++)
					{ 
						float term = data1[oIndex][j] - data2[i][j];
						result += term*term;
					}
					/* no need square root */
					if (dist < min_dist) { /* find the min and its array index */
						min_dist = dist;
						index    = i;
					}
				}
				
		

            /* if membership changes, increase delta by 1 */
            if (membership[i] != index) delta += 1.0;

            /* assign the membership to object i */
            membership[i] = index;

            /* update new cluster center : sum of objects located within */
            newClusterSize[index]++;
            for (j=0; j<numCoords; j++)
                newClusters[index][j] += objects[i][j];
        }

        /* average the sum and replace old cluster center with newClusters */
        for (i=0; i<numClusters; i++) {
            for (j=0; j<numCoords; j++) {
                if (newClusterSize[i] > 0)
                    clusters[i][j] = newClusters[i][j] / newClusterSize[i];                	
                	newClusters[i][j] = 0.0;   /* set back to 0 */
            }
            newClusterSize[i] = 0;   /* set back to 0 */
        }
            
        delta /= numObjs;
    } while (delta > threshold && loop++ < 500);

    free(newClusters[0]);
    free(newClusters);
    free(newClusterSize);

    return 1;
}